<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Rem ‚Äî An AI Companion</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<script type="importmap">
{
  "imports": {
    "three": "/static/vendor/three.module.js"
  }
}
</script>
<style>
  :root{ --fg:#f4f7ff; --glass:#0b1020cc; --line:#23314a; --green:#00d68f; }
  *{box-sizing:border-box;font-family:Inter,system-ui,Segoe UI,Roboto,sans-serif}
  html,body{height:100%;margin:0;background:#0b0e14;color:var(--fg);overflow:hidden}
  #scene3d{position:fixed;inset:0;z-index:0;background:#0c0f18}
  #panel{position:fixed;right:0;top:0;height:100%;width:min(520px,90vw);
         display:flex;flex-direction:column;gap:12px;padding:18px;
         background:linear-gradient(180deg,#0b1020a0,#0b1020a0);backdrop-filter:blur(8px);
         border-left:1px solid #1e2a3f;z-index:2}
  #log{flex:1;min-height:0;overflow:auto;padding-right:6px}
  .bubble{padding:12px 14px;border-radius:14px;margin:8px 0;border:1px solid #1e2a3f}
  .user{background:#12233e}.bot{background:#151c2a}
  .row{display:flex;gap:8px}
  input,button{font:15px/1.2 inherit;padding:12px 14px;border-radius:14px;border:1px solid #1e2a3f;background:#101827;color:var(--fg)}
  input{flex:1;min-width:0} button{cursor:pointer;font-weight:600}
  button:hover{filter:brightness(1.06)} button:disabled{opacity:.55;cursor:not-allowed}
  #voicebar{position:fixed;left:16px;bottom:16px;z-index:2;display:flex;align-items:center;gap:10px;
            background:var(--glass);border:1px solid #1e2a3f;padding:8px 12px;border-radius:12px}
  .pill{display:inline-flex;align-items:center;gap:8px;padding:6px 10px;border-radius:999px;background:#0e1627;border:1px solid #26344b;font-size:13px}
  .dot{width:10px;height:10px;border-radius:50%;background:#78859a}.dot.on{background:var(--green);box-shadow:0 0 10px var(--green)}
  #badge{position:fixed;top:16px;left:16px;z-index:2;padding:8px 12px;border-radius:12px;border:1px solid #1e2a3f;background:var(--glass);font-weight:700;letter-spacing:.3px}
  #subtitle{position:fixed;left:50%;bottom:18%;transform:translateX(-50%);z-index:2;
       max-width:min(70vw,900px); text-align:center; padding:10px 14px; border-radius:12px;
       background:#0e1627cc; border:1px solid #23314a; color:#e9f2ff; opacity:0; transition:opacity .25s ease}
  #subtitle.show{ opacity:1 }
</style>
</head>
<body>
  <div id="scene3d"><div style="position:absolute;inset:0;display:grid;place-items:center;color:#9fb3d1">Loading 3D‚Ä¶</div></div>
  <div id="badge">Rem</div>
  <div id="subtitle" aria-live="polite"></div>

  <aside id="panel">
    <div style="font-weight:700;letter-spacing:.4px">Chat</div>
    <div id="log"></div>
    <div class="row">
      <input id="inp" placeholder="Say something‚Ä¶" />
      <button id="send">Send</button>
    </div>
  </aside>

  <div id="voicebar">
    <button id="mic">üéôÔ∏è Start Voice</button>
    <button id="stop" disabled>‚èπÔ∏è Stop</button>
    <button id="test">‚ñ∂Ô∏è Test Voice</button>
    <span class="pill"><span id="micdot" class="dot"></span><span id="miclabel">Idle</span></span>
  </div>

<script type="module">
/* ====== Avatar Source ======
 * Use your RPM URL WITH morphTargets=ARKit, e.g.:
 *   https://models.readyplayer.me/<id>.glb?morphTargets=ARKit
 * Or keep the local file if it contains blend-shapes.
 */
const RPM_AVATAR_URL =
  "https://models.readyplayer.me/689aceb4c911aabc2e8f9af4.glb?morphTargets=ARKit";

/* ====== Imports ====== */
import * as THREE from "three";
import { GLTFLoader }  from "/static/vendor/GLTFLoader.js";
import { DRACOLoader } from "/static/vendor/DRACOLoader.js";
import { OrbitControls } from "/static/vendor/OrbitControls.js";

/* ====== UI ====== */
const scene3d = document.getElementById('scene3d');
const logEl = document.getElementById('log');
const inp = document.getElementById('inp');
const sendBtn = document.getElementById('send');
const micBtn = document.getElementById('mic');
const stopBtn = document.getElementById('stop');
const testBtn = document.getElementById('test');
const micdot = document.getElementById('micdot');
const miclabel = document.getElementById('miclabel');
const subtitle = document.getElementById('subtitle');

function add(text, who){
  const d = document.createElement('div');
  d.className = 'bubble '+who;
  d.textContent = text;
  logEl.appendChild(d); d.scrollIntoView({behavior:'smooth', block:'end'});
}

/* ====== 3D ====== */
let renderer, scene, camera, controls, clock;
let root=null, headBone=null, jawBone=null, eyeL=null, eyeR=null;
let jawTargets=[], smileTargets=[], blinkTargetsL=[], blinkTargetsR=[], blinkTargetsBoth=[];
let jawEnergy=0, smile=0, threeReady=false;
function setJawEnergy(v){ jawEnergy=Math.min(1,Math.max(0,v)); }

function frameObject(obj){
  const box = new THREE.Box3().setFromObject(obj);
  const size = new THREE.Vector3(), c = new THREE.Vector3();
  box.getSize(size); box.getCenter(c);
  c.y += size.y*0.28;
  const dist = (size.y*0.55)/Math.tan(THREE.MathUtils.degToRad(camera.fov*0.5));
  camera.position.set(c.x, c.y+0.06, c.z+dist*0.48);
  camera.lookAt(c); controls.target.copy(c); controls.update();
}
function faceCameraIfBackwards(){
  if(!headBone || !root) return;
  const fwd = new THREE.Vector3(0,0,1);
  headBone.getWorldDirection(fwd);
  const toCam = new THREE.Vector3().subVectors(camera.position, headBone.getWorldPosition(new THREE.Vector3())).normalize();
  if (fwd.dot(toCam) < 0) root.rotateY(Math.PI);
}

async function init3D(url){
  const w = scene3d.clientWidth, h = scene3d.clientHeight;
  renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true, powerPreference:'high-performance' });
  renderer.setPixelRatio(Math.min(2, window.devicePixelRatio||1));
  renderer.setSize(w, h);
  try{
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.1;
    renderer.physicallyCorrectLights = true;
  }catch{}
  scene3d.innerHTML=''; scene3d.appendChild(renderer.domElement);

  scene = new THREE.Scene();
  camera = new THREE.PerspectiveCamera(24, w/h, 0.1, 100);

  const hemi = new THREE.HemisphereLight(0xffffff, 0x334466, 0.9);
  const dir  = new THREE.DirectionalLight(0xffffff, 1.0); dir.position.set(1,1,1);
  scene.add(hemi, dir);

  controls = new OrbitControls(camera, renderer.domElement);
  controls.enableZoom=false; controls.enablePan=false;

  clock = new THREE.Clock();
  const loader = new GLTFLoader();
  const draco  = new DRACOLoader();
  draco.setDecoderPath("/static/vendor/draco/");
  loader.setDRACOLoader(draco);

  const gltf = await loader.loadAsync(url);
  root = gltf.scene; scene.add(root);

  root.traverse(o=>{
    if (/head\b/i.test(o.name) && !headBone) headBone = o;
    if (!jawBone && /\b(jaw|mouth)\b/i.test(o.name)) jawBone = o;
    if (!eyeL && /eye[._\s-]*l|left\s*eye/i.test(o.name))  eyeL = o;
    if (!eyeR && /eye[._\s-]*r|right\s*eye/i.test(o.name)) eyeR = o;
    if (o.isMesh && o.morphTargetDictionary && o.morphTargetInfluences){
      const dict = o.morphTargetDictionary;
      for (const key in dict){
        const idx = dict[key], k = key.toLowerCase();
        if (/jaw|mouth\s*open|openmouth|aa\b|ah\b|aah|big_ah|vowel_ah/.test(k)) jawTargets.push({mesh:o, idx});
        if (/smile|mouth\s*smile|mouthcornerpull|happy|smirk/.test(k))         smileTargets.push({mesh:o, idx});
        const blinkLike = /blink|eyelid|eye\s*close|eyesclosed|closeeye|eye\s*shut/.test(k);
        if (blinkLike){
          const isL = /left|\bl\b|_l|\.l|eye_l|eye\.l|blinkl/.test(k);
          const isR = /right|\br\b|_r|\.r|eye_r|eye\.r|blinkr/.test(k);
          if (isL) blinkTargetsL.push({mesh:o, idx});
          else if (isR) blinkTargetsR.push({mesh:o, idx});
          else blinkTargetsBoth.push({mesh:o, idx});
        }
      }
    }
  });

  frameObject(root);
  faceCameraIfBackwards();

  // entrance + lively idle
  const startT = clock.getElapsedTime();
  const fromZ = (root.position.z||0)+0.9, toZ = (root.position.z||0);
  root.position.z = fromZ;

  let nextBlinkT = 0, lastBlinkT = 0, prevSmile = 0;
  const gaze = { x:0,y:0,t:0 };

  function loop(){
    const t = clock.getElapsedTime();
    // entrance
    const dt = t - startT, dur=2.2, p=Math.min(1,dt/dur), ease=1-(1-p)*(1-p);
    root.position.z = fromZ + (toZ-fromZ)*ease;

    // visible idle motion
    root.rotation.y = Math.sin(t*0.5) * 0.10;
    root.position.y = Math.sin(t*0.9) * 0.045;

    // head nod (idle + speech)
    const idleNod = Math.sin(t*0.8)*0.035;
    const speakNod = (jawEnergy-0.12)*0.06;
    if (headBone) headBone.rotation.x = THREE.MathUtils.lerp(headBone.rotation.x, idleNod+speakNod, 0.15);

    // jaw (morphs or bone)
    if (jawTargets.length){
      for (const j of jawTargets){ j.mesh.morphTargetInfluences[j.idx] = jawEnergy; }
    } else if (jawBone){
      const maxOpen = THREE.MathUtils.degToRad(12);
      jawBone.rotation.x = THREE.MathUtils.lerp(jawBone.rotation.x, jawEnergy*maxOpen, 0.2);
    }

    // smile level (idle + speech)
    const idleSmile = 0.10 + Math.max(0,Math.sin(t*0.5))*0.07;
    const speakSmile = jawEnergy*0.35;
    const sLevel = THREE.MathUtils.clamp(idleSmile+speakSmile+smile*0.2, 0, 0.85);
    let appliedSmile=false;
    for (const s of smileTargets){ s.mesh.morphTargetInfluences[s.idx] = THREE.MathUtils.lerp(s.mesh.morphTargetInfluences[s.idx]||0, sLevel, 0.12); appliedSmile=true; }
    if (!appliedSmile && headBone){ headBone.rotation.z = THREE.MathUtils.lerp(headBone.rotation.z, (jawEnergy*0.08)*(Math.sin(t*0.6)*0.4), 0.08); }
    if (sLevel>0.33 && prevSmile<=0.33) showSubtitle('[smiles]',1200);
    prevSmile = sLevel;

    // blinking
    if (t>nextBlinkT){ nextBlinkT=t+2.6+Math.random()*2.4; lastBlinkT=t; }
    const bDur=0.26, bPhase=Math.max(0,1-Math.abs((t-lastBlinkT)-bDur*0.5)/(bDur*0.5));
    const bLevel=THREE.MathUtils.clamp(bPhase, 0, 1);
    let hasBlink=false;
    for (const b of blinkTargetsL){ b.mesh.morphTargetInfluences[b.idx]=bLevel; hasBlink=true; }
    for (const b of blinkTargetsR){ b.mesh.morphTargetInfluences[b.idx]=bLevel; hasBlink=true; }
    for (const b of blinkTargetsBoth){ b.mesh.morphTargetInfluences[b.idx]=bLevel; hasBlink=true; }
    if (!hasBlink && (eyeL||eyeR)){ const e=bLevel*0.12; if(eyeL) eyeL.rotation.x=THREE.MathUtils.lerp(eyeL.rotation.x,e,0.25); if(eyeR) eyeR.rotation.x=THREE.MathUtils.lerp(eyeR.rotation.x,e,0.25); }

    // eye saccades
    if ((eyeL||eyeR) && headBone){
      gaze.t -= clock.getDelta();
      if (gaze.t<=0){ gaze.t=0.6+Math.random()*1.2; gaze.x=(Math.random()*2-1)*0.12; gaze.y=(Math.random()*2-1)*0.08; }
      if (eyeL){ eyeL.rotation.y = THREE.MathUtils.lerp(eyeL.rotation.y, gaze.x, 0.08);
                 eyeL.rotation.x = THREE.MathUtils.lerp(eyeL.rotation.x, gaze.y, 0.08); }
      if (eyeR){ eyeR.rotation.y = THREE.MathUtils.lerp(eyeR.rotation.y, gaze.x, 0.08);
                 eyeR.rotation.x = THREE.MathUtils.lerp(eyeR.rotation.x, gaze.y, 0.08); }
    }

    controls.update(); renderer.render(scene, camera); requestAnimationFrame(loop);
  }
  loop();

  window.addEventListener('resize', ()=>{
    const W=scene3d.clientWidth, H=scene3d.clientHeight;
    renderer.setSize(W,H); camera.aspect=W/H; camera.updateProjectionMatrix();
    if(root) frameObject(root);
  });
}
(async function boot(){
  try{ await init3D(RPM_AVATAR_URL); threeReady=true; }
  catch(e){
    console.warn('3D load failed', e);
    const overlay = scene3d.querySelector('div');
    if(overlay) overlay.textContent='3D failed to load. Ensure ARKit morphs or check /static/vendor files.';
  }
})();
function showSubtitle(text, ttl=4000){
  subtitle.textContent=text; subtitle.classList.add('show');
  setTimeout(()=>subtitle.classList.remove('show'), ttl);
}

/* ====== Persistent AudioContext + lip-sync ====== */
let AC = null;                 // one AudioContext reused (prevents ‚Äúno more audio‚Äù after Stop)
let speaking=false, currentAudio=null, analyser=null, srcNode=null, raf=null;
let curStreamCtrl=null, curTtsCtrl=null, speakQ=Promise.resolve();

function ensureAC(){
  if (!AC) AC = new (window.AudioContext||window.webkitAudioContext)();
  if (AC.state!=='running') AC.resume().catch(()=>{});
  return AC;
}
function hardCleanup(){
  try{ if(raf) cancelAnimationFrame(raf); }catch{}
  raf=null;
  try{ if(srcNode){ srcNode.disconnect(); srcNode=null; } }catch{}
  try{ if(analyser){ analyser.disconnect(); analyser=null; } }catch{}
  try{ if(currentAudio){ currentAudio.pause(); currentAudio.src=''; } }catch{}
  currentAudio=null;
  setJawEnergy(0);
}
function stopAll(){
  speaking=false;
  hardCleanup();
  try{ if(curStreamCtrl){ curStreamCtrl.abort(); curStreamCtrl=null; } }catch{}
  try{ if(curTtsCtrl){ curTtsCtrl.abort();  curTtsCtrl=null;  } }catch{}
  try{ speakQ = Promise.resolve(); }catch{}
  // do not close AC ‚Äî keep it for next plays (avoids ‚Äúno speech after stop‚Äù)
  showSubtitle('');
}

/* --- TTS/Viseme --- */
async function ttsFull(text){
  for(let attempt=0; attempt<3; attempt++){
    try{
      const ctrl = new AbortController(); curTtsCtrl = ctrl;
      const r = await fetch('/api/tts',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({text}),signal:ctrl.signal});
      if(r.status===429 || r.status===502 || r.status===503){ await new Promise(res=>setTimeout(res, 250*(2**attempt))); continue; }
      const d = await r.json(); curTtsCtrl=null; return d;
    }catch(e){
      if(e.name==='AbortError') throw e;
      await new Promise(res=>setTimeout(res, 200*(2**attempt)));
    }
  }
  throw new Error('tts-failed');
}
const VMAP = { "sil":0.00, "p":0.15, "t":0.2, "f":0.22, "k":0.22, "S":0.2, "T":0.22, "r":0.28, "w":0.3,
               "e":0.55, "i":0.6, "o":0.75, "u":0.78, "@":0.5, "a":0.95 };
const vOpen = v => (VMAP[v] ?? 0.35);

async function playWithVisemes(b64, marks){
  return new Promise(async (resolve, reject)=>{
    speaking=true; hardCleanup();
    const audio = new Audio('data:audio/mp3;base64,'+b64); currentAudio=audio;
    const ac = ensureAC();
    analyser = ac.createAnalyser(); analyser.fftSize = 512;

    try{
      srcNode = ac.createMediaElementSource(audio);
      srcNode.connect(analyser); analyser.connect(ac.destination);
    }catch(e){
      // If the element was connected to an old context, fall back to simple play
      console.warn('MediaElementSource error, simple play fallback', e);
      audio.onended = ()=>{ setJawEnergy(0); speaking=false; resolve(); };
      audio.onerror = ()=>{ setJawEnergy(0); speaking=false; reject(new Error('audio-error')); };
      audio.play().catch(err=>{ console.warn(err); resolve(); });
      return;
    }

    try{ if(ac.state!=='running') await ac.resume(); }catch{}
    audio.onended = ()=>{ setJawEnergy(0); speaking=false; resolve(); };
    audio.onerror = ()=>{ setJawEnergy(0); speaking=false; reject(new Error('audio-error')); };
    audio.onpause = ()=>{ setJawEnergy(0); speaking=false; resolve(); }; // treat Stop as clean end

    audio.play().catch(err=>{ console.warn('audio.play failed', err); resolve(); });

    let idx=0, target=0.2, level=0.15;
    const data = new Uint8Array(analyser.frequencyBinCount);
    const startedAt = performance.now();

    const tick=()=>{
      if(!speaking) return;
      const tms = performance.now() - startedAt;

      while(Array.isArray(marks) && idx<marks.length && marks[idx].time <= tms + 30){
        target = vOpen(marks[idx].value); idx++;
      }
      analyser.getByteTimeDomainData(data);
      let s=0; for(let i=0;i<data.length;i++){ const v=(data[i]-128)/128; s+=v*v; }
      const rms=Math.sqrt(s/data.length);
      const assist = Math.min(0.25, rms*0.6);
      level = level*0.6 + (target+assist)*0.4;

      setJawEnergy(Math.max(0, Math.min(1, level)));
      raf = requestAnimationFrame(tick);
    };
    raf = requestAnimationFrame(tick);
  });
}
function enqueueSpeak(sentence){
  const s = (sentence||'').trim(); if(!s) return;
  speakQ = speakQ.then(async ()=>{
    try{
      const {audio_b64, marks} = await ttsFull(s);
      await playWithVisemes(audio_b64, marks||[]);
    }catch(e){
      if(e.name==='AbortError') return; // interrupted
      // tiny browser TTS fallback
      try{
        const synth = window.speechSynthesis; if(!synth) return;
        const u = new SpeechSynthesisUtterance(s); u.rate=1; u.pitch=1.05;
        synth.cancel(); synth.speak(u);
      }catch{}
    }
  });
}

/* ====== Chat stream with sentence TTS ====== */
async function talk(text){
  stopAll(); // cancel anything pending cleanly
  const q = (text||'').trim(); if(!q) return;
  add(q, 'user');

  const bubble = document.createElement('div'); bubble.className='bubble bot'; bubble.textContent=''; logEl.appendChild(bubble);
  let buf='', leftover=''; const dec=new TextDecoder();

  try{
    const ctrl = new AbortController(); curStreamCtrl = ctrl;
    const r = await fetch('/api/chat_stream',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({text:q, session_id:'local-1'}),signal:ctrl.signal});
    const reader = r.body.getReader();
    while(true){
      const {value, done} = await reader.read(); if(done) break;
      leftover += dec.decode(value,{stream:true});
      const lines = leftover.split('\n'); leftover = lines.pop();
      for(const line of lines){
        if(!line.trim()) continue;
        const {delta='', error} = JSON.parse(line);
        if(error){ bubble.textContent += ` [${error}]`; continue; }
        bubble.textContent += delta; buf += delta; showSubtitle(bubble.textContent.slice(-220));
        const m = buf.match(/(.+?[.!?][)"']?\s)/);
        if(m && m[1].trim().length>3){ enqueueSpeak(m[1]); buf = buf.slice(m[1].length); }
      }
    }
    if(buf.trim()){ showSubtitle(buf.trim()); enqueueSpeak(buf.trim()); buf=''; }
    await speakQ; curStreamCtrl=null;
  }catch(e){
    if(e.name==='AbortError'){ curStreamCtrl=null; return; } // interrupted
    const rr = await fetch('/api/chat',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({text:q, session_id:'local-1'})});
    const dd = await rr.json(); bubble.textContent = dd.reply || "I'm here.";
    showSubtitle(bubble.textContent); enqueueSpeak(bubble.textContent); await speakQ;
    curStreamCtrl=null;
  }
}

/* ====== Input & mic ====== */
sendBtn.onclick = ()=>{ const t = inp.value.trim(); if(t){ talk(t); inp.value=''; } };
inp.addEventListener('keydown', e=>{ if(e.key==='Enter'){ e.preventDefault(); sendBtn.click(); } });

const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
let recog=null;
function setListening(on){ micdot.classList.toggle('on', on); miclabel.textContent = on ? 'Listening‚Ä¶' : 'Idle'; if(on && speaking) stopAll(); }
micBtn.onclick = ()=>{
  if(!SR){ alert('Use Chrome/Edge for speech input.'); return; }
  recog = new SR(); recog.lang='en-US'; recog.interimResults=true; recog.continuous=true;
  let buffer='';
  recog.onstart = ()=>{ micBtn.disabled=true; stopBtn.disabled=false; setListening(true); };
  recog.onresult = (ev)=>{ for(let i=ev.resultIndex;i<ev.results.length;i++){ const r=ev.results[i]; if(r.isFinal) buffer += ' '+r[0].transcript; }
    const cleaned = buffer.trim(); if(cleaned){ talk(cleaned); buffer=''; } };
  recog.onend = ()=>{ micBtn.disabled=false; stopBtn.disabled=true; setListening(false); };
  recog.onerror = e=>console.warn(e);
  recog.start();
};
stopBtn.onclick = ()=>{ try{ if(recog) recog.stop(); }catch{} stopAll(); };
testBtn.onclick = ()=> enqueueSpeak("Hey! I'm Rem. Nice to meet you.");

// Unlock audio on any gesture
['pointerdown','keydown'].forEach(evt=>{
  window.addEventListener(evt, ()=>{ try{ ensureAC(); }catch{} }, {passive:true});
});
</script>
</body>
</html>
