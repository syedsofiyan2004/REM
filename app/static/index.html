<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Rem ‚Äî Companion</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<meta name="theme-color" content="#0b0e14" />
<script type="importmap">
{
  "imports": {
    "three": "/static/vendor/three.module.js"
  }
}
</script>
<style>
  :root{ --fg:#f4f7ff; --glass:#0b1020cc; --line:#23314a; --green:#00d68f; --bg:#0b0e14; --pill:#13233c; --pillBorder:#2a3d59; }
  *{box-sizing:border-box;font-family:Inter,system-ui,Segoe UI,Roboto,sans-serif}
  html,body{height:100%;margin:0;background:var(--bg);color:var(--fg);overflow:hidden}
  #scene3d{position:fixed;inset:0;z-index:0;background:#0c0f18}
  #panel{position:fixed;right:0;top:0;height:100%;width:min(520px,96vw);
         display:flex;flex-direction:column;gap:12px;padding:18px;padding-bottom:16px;
         background:linear-gradient(180deg,#0b1020a0,#0b1020a0);backdrop-filter:blur(8px);
    border-left:1px solid #1e2a3f;z-index:2;
    transform:translateX(100%); transition:transform .25s ease}
  #panel.open{ transform:translateX(0) }
  #log{flex:1;min-height:0;overflow:auto;padding-right:6px}
  .bubble{padding:14px 16px;border-radius:14px;margin:10px 0;border:1px solid #1e2a3f;line-height:1.5;overflow-wrap:anywhere}
  .user{background:#0f223f}
  .bot{background:#121a2a}
  .row{display:flex;gap:8px}
  input,button,select{font:16px/1.35 inherit;padding:12px 14px;border-radius:14px;border:1px solid #1e2a3f;background:#101827;color:var(--fg)}
  input{flex:1;min-width:0} button{cursor:pointer;font-weight:600}
  button:hover{filter:brightness(1.06)} button:disabled{opacity:.55;cursor:not-allowed}
  #voicebar{position:fixed;left:12px;bottom:calc(env(safe-area-inset-bottom, 0px) + 12px);z-index:2;display:inline-flex;align-items:center;gap:8px;
            background:var(--glass);border:1px solid #1e2a3f;padding:8px 10px;border-radius:12px;flex-wrap:nowrap;overflow-x:auto;white-space:nowrap;
            max-width:min(70vw, 820px)}
  .pill{display:inline-flex;align-items:center;gap:8px;padding:6px 10px;border-radius:999px;background:var(--pill);border:1px solid var(--pillBorder);font-size:13px;color:#eaf2ff}
  .pill:focus-visible{outline:2px solid var(--green)}
  select.pill{appearance:none;background:var(--pill);color:#eaf2ff}
  .dot{width:10px;height:10px;border-radius:50%;background:#78859a}.dot.on{background:var(--green);box-shadow:0 0 10px var(--green)}
  #badge{position:fixed;top:16px;left:16px;z-index:2;padding:8px 12px;border-radius:12px;border:1px solid #1e2a3f;background:var(--glass);font-weight:700;letter-spacing:.3px}
  #hambtn{position:fixed;top:16px;right:16px;z-index:3;padding:8px 10px;border-radius:10px;border:1px solid #1e2a3f;background:var(--glass);font-weight:700}
  #subtitle{position:fixed;left:50%;bottom:24%;transform:translateX(-50%);z-index:2;
       max-width:min(70vw,900px); text-align:center; padding:10px 14px; border-radius:12px;
       background:#0e1627f0; border:1px solid #23314a; color:#e9f2ff; text-shadow:0 1px 2px #000; opacity:0; transition:opacity .25s ease}
  #subtitle.show{ opacity:1 }
  /* Zoom toolbar */
  #zoombar{position:fixed;left:16px;bottom:calc(env(safe-area-inset-bottom, 0px) + 100px);z-index:3;display:flex;flex-direction:column;gap:8px}
  #zoombar button{padding:8px 10px;border-radius:10px;border:1px solid #1e2a3f;background:var(--glass);font-weight:700;color:var(--fg)}
  #disclaimer{position:fixed;left:50%;top:12px;transform:translateX(-50%);z-index:3;
    padding:8px 12px;border-radius:10px;border:1px solid #2a3a55;background:#0b1020e6;color:#c6d6ec;
    font-size:13px}
  /* Accessibility toggles */
  body.large-text { font-size:18px }
  body.large-text input, body.large-text button { font-size:18px }
  body.high-contrast { --fg:#ffffff; --bg:#0a0d14 }
  body.high-contrast .bubble { border-color:#35507a }
  body.high-contrast .user { background:#0d2a52 }
  body.high-contrast .bot  { background:#0f1930 }
  /* Onboarding toast removed for a cleaner UI */
  /* Mobile tweaks */
  @media (max-width: 768px){
    #panel{width:100vw; padding:14px}
    #badge{top:auto; bottom:calc(env(safe-area-inset-bottom, 0px) + 72px)}
    #subtitle{bottom:36%}
  #voicebar{left:8px; max-width:86vw;}
    input,button{font-size:17px} /* bigger tap targets */
    /* Hide zoom controls on small screens to avoid overlaps */
    #zoombar{display:none}
  }
  /* Zoom bar stays on the left to avoid panel overlap */
</style>
</head>
<body>
  <div id="scene3d"><div style="position:absolute;inset:0;display:grid;place-items:center;color:#9fb3d1">Loading 3D‚Ä¶</div></div>
  <div id="badge">Rem</div>
  <button id="hambtn">‚ò∞</button>
  <div id="subtitle" aria-live="polite"></div>
  <div id="disclaimer">Preview build: This experience is under active development and may be imperfect.</div>

  <aside id="panel">
    <div style="font-weight:700;letter-spacing:.4px">Chat</div>
    <div id="log"></div>
    <div class="row">
      <input id="inp" placeholder="Say something‚Ä¶" />
      <button id="send">Send</button>
    </div>
    <div style="font-weight:700;letter-spacing:.4px;margin-top:6px">Sing</div>
    <div class="row">
      <input id="singinp" placeholder="Type lyrics for singing (not chat)‚Ä¶" />
      <button id="singGo">Sing</button>
    </div>
    <div class="row" style="flex-wrap:wrap;gap:8px;margin-top:6px">
  <button class="pill" data-say="Tell me a short story about kindness.">üí° Story</button>
  <button class="pill" data-say="Guide me through a 30-second breathing exercise.">üßò Breathe</button>
  <button class="pill" data-say="Teach me a fun fact about space.">üõ∞Ô∏è Space</button>
  <button class="pill" data-say="Help me plan a quick healthy snack.">ü•ó Snack</button>
  <!-- Style quick toggles (Grok-like modes) -->
  <button class="pill style" data-style="witty" title="Witty mode">‚ú® Witty</button>
  <button class="pill style" data-style="empathetic" title="Empathetic mode">üíû Empathetic</button>
  <button class="pill style" data-style="precise" title="Precise mode">üß† Precise</button>
  <button class="pill style" data-style="spicy" title="Flirty but safe">üå∂Ô∏è Spicy</button>
  <button class="pill" id="cardBtn" title="Quick knowledge card">üÉè Card</button>
    </div>
  </aside>

  <div id="voicebar">
    <button id="mic">üéôÔ∏è Start Voice</button>
    <button id="stop" disabled>‚èπÔ∏è Stop</button>
  <button id="pttbtn" class="pill" title="Hold Space to talk when enabled">PTT</button>
  <button id="sing">üéµ Sing</button>
    <select id="langsel" class="pill" title="TTS language">
      <option value="auto" selected>Auto (detect)</option>
      <option value="en">English (Ruth)</option>
      <option value="es">Espa√±ol (Espa√±a)</option>
      <option value="es-mx">Espa√±ol (M√©xico)</option>
      <option value="fr">Fran√ßais (France)</option>
      <option value="fr-ca">Fran√ßais (Canada)</option>
      <option value="hi">‡§π‡§ø‡§Ç‡§¶‡•Ä (India)</option>
    </select>
    <span class="pill"><span id="micdot" class="dot"></span><span id="miclabel">Idle</span></span>
  </div>

  <!-- Zoom controls -->
  <div id="zoombar" aria-label="Viewport zoom controls">
    <button id="zoomIn" title="Zoom in">Ôºã</button>
    <button id="zoomOut" title="Zoom out">Ôºç</button>
    <button id="zoomReset" title="Reset view">‚ü≥</button>
  </div>


<script type="module">
const RPM_AVATAR_URL =
  "/static/models/blessedboy.glb";

/* ====== Imports (use import map to resolve 'three') ====== */
import * as THREE from "three";
import { GLTFLoader }  from "/static/vendor/GLTFLoader.js";
import { DRACOLoader } from "/static/vendor/DRACOLoader.js";
import { OrbitControls } from "/static/vendor/OrbitControls.js";

/* ====== UI refs ====== */
const scene3d   = document.getElementById('scene3d');
const logEl     = document.getElementById('log');
const inp       = document.getElementById('inp');
const sendBtn   = document.getElementById('send');
const micBtn    = document.getElementById('mic');
const stopBtn   = document.getElementById('stop');
const singBtn   = document.getElementById('sing');
const langSel   = document.getElementById('langsel');
const micdot    = document.getElementById('micdot');
const miclabel  = document.getElementById('miclabel');
const panelEl   = document.getElementById('panel');
const hambtn    = document.getElementById('hambtn');
const subtitle  = document.getElementById('subtitle');
const singInp   = document.getElementById('singinp');
const singGoBtn = document.getElementById('singGo');
const zoomInBtn = document.getElementById('zoomIn');
const zoomOutBtn= document.getElementById('zoomOut');
const zoomReset = document.getElementById('zoomReset');
const suggestionButtons = () => Array.from(document.querySelectorAll('#panel .pill[data-say]'));
const styleButtons = () => Array.from(document.querySelectorAll('#panel .pill.style'));
// Typing indicator
let typingEl; (function(){ typingEl = document.createElement('div'); typingEl.className='bubble bot'; typingEl.textContent='‚Ä¶'; typingEl.style.opacity='0.6'; })();
let selectedStyle = null;
// Restore accessibility prefs (kept via body classes; toggles removed from bar)
try{
  const lt = localStorage.getItem('pref-large-text') === '1';
  const hc = localStorage.getItem('pref-high-contrast') === '1';
  document.body.classList.toggle('large-text', lt);
  document.body.classList.toggle('high-contrast', hc);
}catch{}

/* ====== log ====== */
function add(text, who){
  const d = document.createElement('div');
  d.className = 'bubble '+who;
  d.textContent = text;
  logEl.appendChild(d); d.scrollIntoView({behavior:'smooth', block:'end'});
}

/* ====== 3D avatar (deferred) ====== */
let renderer, scene, camera, controls, clock;
let jawTargets=[], smileTargets=[], blinkLeftTargets=[], blinkRightTargets=[], blinkBothTargets=[], headBone=null, jawBone=null, root=null;
let eyeLeftBone=null, eyeRightBone=null; // optional eye bones if present
let jawEnergy=0, threeReady=false;
let smile=0, blink=0, nextBlinkT=0, lastT=0, prevSmileLevel=0;
let entrance = { active: true, startT: 0, fromZ: 0, toZ: 0 };
let exprPulse = { smile: 0, winkL: 0, winkR: 0 }; // short-lived expression pulses
let gaze = { x: 0, y: 0, t: 0 }; // eye saccades target

function setJawEnergy(level){ jawEnergy = Math.max(0, Math.min(1, level)); }
function setSmile(level){ smile = Math.max(0, Math.min(1, level)); }
function setBlink(level){ blink = Math.max(0, Math.min(1, level)); }

function frameObject(obj){
  const box = new THREE.Box3().setFromObject(obj);
  const size = new THREE.Vector3(), center = new THREE.Vector3();
  box.getSize(size); box.getCenter(center);
  center.y += size.y*0.28;                                        // bias toward face/upper body
  const dist = (size.y*0.55) / Math.tan(THREE.MathUtils.degToRad(camera.fov*0.5));
  camera.position.set(center.x, center.y + 0.06, center.z + dist*0.48);  // zoom in closer
  camera.lookAt(center);
  controls.target.copy(center); controls.update();
}
function faceCameraIfBackwards(){
  if(!headBone || !root) return;
  const fwd = new THREE.Vector3(0,0,1);
  headBone.getWorldDirection(fwd);
  const toCam = new THREE.Vector3().subVectors(camera.position, headBone.getWorldPosition(new THREE.Vector3())).normalize();
  if (fwd.dot(toCam) < 0) root.rotateY(Math.PI);
}

async function init3D(url){
  const w = scene3d.clientWidth, h = scene3d.clientHeight;
  renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true, powerPreference:'high-performance' });
  renderer.setPixelRatio(Math.min(2, window.devicePixelRatio||1));
  renderer.setSize(w, h);
  try{
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.1;
    renderer.physicallyCorrectLights = true;
  }catch{}
  scene3d.innerHTML=''; scene3d.appendChild(renderer.domElement);

  scene = new THREE.Scene();
  camera = new THREE.PerspectiveCamera(24, w/h, 0.1, 100);

  const hemi = new THREE.HemisphereLight(0xffffff, 0x334466, 0.9);
  const dir  = new THREE.DirectionalLight(0xffffff, 1.0); dir.position.set(1,1,1);
  scene.add(hemi, dir);

  controls = new OrbitControls(camera, renderer.domElement);
  // Allow user zoom in/out with mouse wheel or pinch
  controls.enableZoom = true; controls.zoomSpeed = 0.7; controls.enablePan = false;
  controls.minDistance = 0.8; controls.maxDistance = 6;

  clock = new THREE.Clock();
  const loader = new GLTFLoader();
  const draco  = new DRACOLoader();
  draco.setDecoderPath("/static/vendor/draco/");
  loader.setDRACOLoader(draco);

  const gltf = await loader.loadAsync(url);
  root = gltf.scene; scene.add(root);

  // Increase texture filtering quality
  try{
    const aniso = renderer.capabilities.getMaxAnisotropy?.() || 8;
    root.traverse(o=>{
      const m = o.material; if(!m) return;
      const tx = ['map','normalMap','metalnessMap','roughnessMap','emissiveMap','aoMap'];
      for(const k of tx){ if(m[k]) m[k].anisotropy = aniso; }
    });
  }catch{}

  root.traverse(o=>{
    if (/head\b/i.test(o.name) && !headBone) headBone = o;
    if (!jawBone && /\b(jaw|mouth)\b/i.test(o.name)) jawBone = o; // fallback bone-based jaw
    // Eye bones (common names): Eye.L/Eye.R, eye_l/eye_r, LeftEye/RightEye
    if (!eyeLeftBone && /eye[._\s-]*l|left\s*eye/i.test(o.name)) eyeLeftBone = o;
    if (!eyeRightBone && /eye[._\s-]*r|right\s*eye/i.test(o.name)) eyeRightBone = o;
    if (o.isMesh && o.morphTargetDictionary && o.morphTargetInfluences){
      const dict = o.morphTargetDictionary;
      for (const key in dict){
        const idx = dict[key]; const k = key.toLowerCase();
        // Jaw / mouth open
        if (/jaw|mouth\s*open|openmouth|aa\b|ah\b|aah|big_ah|vowel_ah/.test(k)) {
          jawTargets.push({ mesh:o, idx });
        }
        // Smile variants
        if (/smile|mouth\s*smile|smileleft|smileright|mouthcornerpull|happy|smirk/.test(k)) {
          smileTargets.push({ mesh:o, idx });
        }
        // Blink variants
        const blinkLike = /blink|eyelid|eye\s*close|eyesclosed|closeeye|eye\s*shut/.test(k);
        if (blinkLike) {
          const isLeft = /left|\bl\b|_l|\.l|eye_l|eye\.l|blinkl/.test(k);
          const isRight = /right|\br\b|_r|\.r|eye_r|eye\.r|blinkr/.test(k);
          if (isLeft) blinkLeftTargets.push({ mesh:o, idx });
          else if (isRight) blinkRightTargets.push({ mesh:o, idx });
          else blinkBothTargets.push({ mesh:o, idx });
        }
      }
    }
  });

  frameObject(root);
  faceCameraIfBackwards();

  // Entrance: start slightly forward and move toward camera
  entrance.startT = clock.getElapsedTime();
  entrance.fromZ = (root.position.z || 0) + 0.9;
  entrance.toZ = root.position.z || 0;
  root.position.z = entrance.fromZ;

  function loop(){
    const t = clock.getElapsedTime();
    // More visible idle motion
    const yaw = Math.sin(t*0.5) * 0.10;   // ~¬±6¬∞
    const bob = Math.sin(t*0.9) * 0.045;  // a bit more bob
    if (root){
      // Entrance easing (quad out)
      if (entrance.active){
        const dt = t - entrance.startT;
        const dur = 2.2; const p = Math.min(1, dt/dur); const e = 1 - (1-p)*(1-p);
        root.position.z = entrance.fromZ + (entrance.toZ - entrance.fromZ)*e;
        if (p >= 1) entrance.active = false;
      }
      root.rotation.y = yaw;
      root.position.y = bob * (entrance.active ? 1.8 : 1.0);
    }

    // Head motion: slight idle nod + speech-driven component
    const idleNod = Math.sin(t*0.8) * 0.035;     // ~¬±2¬∞
    const speakNod = (jawEnergy-0.12) * 0.06;   // a bit stronger while speaking
    if (headBone) headBone.rotation.x = THREE.MathUtils.lerp(headBone.rotation.x, idleNod + speakNod, 0.15);

  // Apply mouth openness to detected morph targets (or rotate jaw bone if no morphs)
    if (jawTargets.length){
      for (const j of jawTargets){ j.mesh.morphTargetInfluences[j.idx] = jawEnergy; }
    } else if (jawBone) {
      const maxOpen = THREE.MathUtils.degToRad(12); // ~12¬∞
      jawBone.rotation.x = THREE.MathUtils.lerp(jawBone.rotation.x, jawEnergy * maxOpen, 0.2);
    }

  // Smile: stronger and includes short-lived pulses
    const idleSmile = 0.10 + Math.max(0, Math.sin(t*0.5))*0.07;
    const speakSmile = jawEnergy * 0.35;
    exprPulse.smile = Math.max(0, exprPulse.smile - 0.02);
    const sLevel = THREE.MathUtils.clamp(idleSmile + speakSmile + exprPulse.smile*0.6 + smile*0.2, 0, 0.8);
  let appliedSmile = false;
  for (const s of smileTargets){ s.mesh.morphTargetInfluences[s.idx] = THREE.MathUtils.lerp(s.mesh.morphTargetInfluences[s.idx]||0, sLevel, 0.1); appliedSmile = true; }
  // If no smile morphs exist, emulate expression subtly by head tilt
  if (!appliedSmile && headBone){ headBone.rotation.z = THREE.MathUtils.lerp(headBone.rotation.z, (jawEnergy*0.08) * (Math.sin(t*0.6)*0.4), 0.08); }

    // Natural blinking (more frequent, random length)
    if (t > nextBlinkT){ nextBlinkT = t + 2.8 + Math.random()*2.8; lastT = t; }
    const bDur = 0.24 + Math.random()*0.08; // 0.24‚Äì0.32s
    const bPhase = Math.max(0, 1 - Math.abs((t-lastT) - bDur*0.5)/(bDur*0.5));
    const bLevel = THREE.MathUtils.clamp(bPhase, 0, 1);
    let hasBlinkMorph = false;
    for (const b of blinkLeftTargets){ b.mesh.morphTargetInfluences[b.idx] = bLevel; hasBlinkMorph = true; }
    for (const b of blinkRightTargets){ b.mesh.morphTargetInfluences[b.idx] = bLevel; hasBlinkMorph = true; }
    for (const b of blinkBothTargets){ b.mesh.morphTargetInfluences[b.idx] = bLevel; hasBlinkMorph = true; }
    // If no blink morphs, do a tiny eye-bone blink emulation (pitch down and back)
    if (!hasBlinkMorph && (eyeLeftBone||eyeRightBone)){
      const e = (bLevel*0.12);
      if (eyeLeftBone) eyeLeftBone.rotation.x = THREE.MathUtils.lerp(eyeLeftBone.rotation.x, e, 0.25);
      if (eyeRightBone) eyeRightBone.rotation.x = THREE.MathUtils.lerp(eyeRightBone.rotation.x, e, 0.25);
    }

    // Eye saccades: subtle gaze shifts if eye bones exist
    if ((eyeLeftBone || eyeRightBone) && headBone){
      gaze.t -= clock.getDelta();
      if (gaze.t <= 0){
        gaze.t = 0.6 + Math.random()*1.2;
        gaze.x = (Math.random()*2-1) * 0.12; // ¬±0.12 rad
        gaze.y = (Math.random()*2-1) * 0.08; // ¬±0.08 rad
      }
      const gx = gaze.x, gy = gaze.y;
      if (eyeLeftBone){ eyeLeftBone.rotation.y = THREE.MathUtils.lerp(eyeLeftBone.rotation.y, gx, 0.08);
                        eyeLeftBone.rotation.x = THREE.MathUtils.lerp(eyeLeftBone.rotation.x, gy, 0.08); }
      if (eyeRightBone){ eyeRightBone.rotation.y = THREE.MathUtils.lerp(eyeRightBone.rotation.y, gx, 0.08);
                         eyeRightBone.rotation.x = THREE.MathUtils.lerp(eyeRightBone.rotation.x, gy, 0.08); }
    }

    // Smile indicator
    if (sLevel > 0.33 && prevSmileLevel <= 0.33) { showSubtitle('[smiles]', 1200); exprPulse.smile = 1.0; }
    prevSmileLevel = sLevel;

    controls.update();
    renderer.render(scene, camera);
    requestAnimationFrame(loop);
  }
  loop();

  window.addEventListener('resize', ()=>{
    const W = scene3d.clientWidth, H = scene3d.clientHeight;
    renderer.setSize(W,H); camera.aspect = W/H; camera.updateProjectionMatrix();
    if (root) frameObject(root);
  });

  // Pointer-driven subtle gaze targeting (if eye bones exist)
  let lastPointerAt = 0;
  window.addEventListener('pointermove', (ev)=>{
    if(!(eyeLeftBone||eyeRightBone)) return;
    const x = ev.clientX / window.innerWidth;
    const y = ev.clientY / window.innerHeight;
    gaze.x = (x - 0.5) * 0.22;   // left/right
    gaze.y = (0.5 - y) * 0.14;   // up/down
    gaze.t = 0.6;                // hold this target for a bit
    lastPointerAt = performance.now();
  }, {passive:true});

  threeReady = true;
}
function schedule3D(){
  const start = ()=>
    init3D(RPM_AVATAR_URL)
      .catch(async (err)=>{
        console.warn("Remote 3D load failed, trying local fallback:", err);
        try{
          await init3D('/static/models/blessedboy.glb');
        }catch(e2){
          console.error("Local 3D fallback failed:", e2);
          const overlay = scene3d.querySelector('div');
          if(overlay) overlay.textContent = '3D failed to load. Check network or local assets.';
        }
      })
      .finally(()=>scene3d.style.pointerEvents = "auto");
  (window.requestIdleCallback || ((f)=>setTimeout(f,250)))(start);
}
scene3d.style.pointerEvents = "none";
// Basic WebGL support check
try{
  const test = document.createElement('canvas').getContext('webgl') || document.createElement('canvas').getContext('experimental-webgl');
  if(!test){
    const overlay = scene3d.querySelector('div');
    if(overlay) overlay.textContent = 'WebGL not supported. Try a newer browser or update graphics drivers.';
  }else{
    schedule3D();
    // If it takes too long, surface a hint
    setTimeout(()=>{
      if(!threeReady){
        const overlay = scene3d.querySelector('div');
        if(overlay) overlay.textContent = 'Still loading 3D‚Ä¶ Check /static/vendor and /static/models files.';
      }
    }, 8000);
  }
}catch{
  const overlay = scene3d.querySelector('div');
  if(overlay) overlay.textContent = '3D init error. See console for details.';
}

/* ====== TTS with visemes ====== */
let curTtsCtrl = null; // abort controller for active TTS fetch
let selectedLang = 'auto';
let lastLangHint = 'en'; // remember last detected language for ASR
function detectLang(s){
  const t = (s||'').trim();
  if(!t) return lastLangHint || 'en';
  // Script check: Devanagari
  if(/[\u0900-\u097F]/.test(t)) return 'hi';
  const lower = t.toLowerCase();
  const score = {en:0, es:0, fr:0};
  [' the ',' and ',' you ',' hello',' hi '].forEach(w=>{ if(lower.includes(w)) score.en++; });
  [' el ',' la ',' de ',' que ',' y ',' como ',' gracias',' por ',' puedo ',' hola '].forEach(w=>{ if(lower.includes(w)) score.es++; });
  [' le ',' la ',' des ',' et ',' je ',' vous ',' bonjour',' merci',' avec '].forEach(w=>{ if(lower.includes(w)) score.fr++; });
  if(/[√°√©√≠√≥√∫√±¬°¬ø]/i.test(t)) score.es+=2;
  if(/[√†√¢√ß√©√®√™√´√Æ√Ø√¥√π√ª√º√ø≈ì]/i.test(t)) score.fr+=2;
  let best='en', bestV=-1; for(const k in score){ if(score[k]>bestV){ best=k; bestV=score[k]; } }
  if(bestV<=0) return lastLangHint || 'en';
  return best;
}
function ttsPayload(text){
  let lang = selectedLang || 'en';
  if(lang === 'auto'){
    lang = detectLang(text);
    lastLangHint = lang || lastLangHint;
  }
  const mode = lang !== 'en' ? 'auto' : null; // keep Ruth for English by default
  return { text, lang, mode };
}
async function ttsFull(text){
  // Retry a couple times on 429/5xx to smooth out transient throttling
  let lastErr;
  for(let attempt=0; attempt<3; attempt++){
    try{
  const ctrl = new AbortController(); curTtsCtrl = ctrl;
  const timeout = setTimeout(()=>{ try{ ctrl.abort(); }catch{} }, 30000);
      const r = await fetch('/api/tts',{
        method:'POST', headers:{'Content-Type':'application/json'}, body:JSON.stringify(ttsPayload(text)), signal: ctrl.signal
      });
  clearTimeout(timeout);
      if(r.status===429 || r.status===503 || r.status===502){
        const back = 250*Math.pow(2,attempt) + Math.random()*150; await new Promise(res=>setTimeout(res, back));
        continue;
      }
      const d = await r.json(); return d; // {audio_b64, marks}
    }catch(e){
      if(e && (e.name==='AbortError' || String(e).includes('AbortError'))){ throw e; }
      lastErr = e; const back = 200*Math.pow(2,attempt); await new Promise(res=>setTimeout(res, back));
    } finally {
      curTtsCtrl = null;
    }
  }
  throw lastErr || new Error('tts-retries-exhausted');
}

async function singOnce(text){
  let lastErr;
  for(let attempt=0; attempt<3; attempt++){
    try{
      const ctrl = new AbortController(); curTtsCtrl = ctrl;
  const timeout = setTimeout(()=>{ try{ ctrl.abort(); }catch{} }, 30000);
      const r = await fetch('/api/sing',{
        method:'POST', headers:{'Content-Type':'application/json'}, body:JSON.stringify(ttsPayload(text)), signal: ctrl.signal
      });
      clearTimeout(timeout);
      if(r.status===429 || r.status===503 || r.status===502){
        const back = 250*Math.pow(2,attempt) + Math.random()*150; await new Promise(res=>setTimeout(res, back));
        continue;
      }
      const d = await r.json(); return d; // {audio_b64, marks}
    }catch(e){
      if(e && (e.name==='AbortError' || String(e).includes('AbortError'))){ throw e; }
      lastErr = e; const back = 200*Math.pow(2,attempt); await new Promise(res=>setTimeout(res, back));
    } finally { curTtsCtrl = null; }
  }
  throw lastErr || new Error('sing-retries-exhausted');
}

/* ====== Lip-sync (visemes + RMS fallback) ====== */
let speaking=false, currentAudio=null, audioCtx=null, raf=null;
let curStreamCtrl = null; // abort controller for active chat_stream
// Mic echo control
let autoResumeMic = false;          // deprecated: we no longer pause mic during TTS
let suppressASRUntil = 0;           // timestamp (performance.now) to ignore ASR results until after TTS ends
function stopSpeaking(){
  speaking=false;
  try{ if(currentAudio){ currentAudio.pause(); currentAudio.src=''; } }catch{}
  if(raf) cancelAnimationFrame(raf); currentAudio=null;
  setJawEnergy(0);
  if(audioCtx){ try{ audioCtx.close(); }catch{} audioCtx=null; }
  try{ if(window.speechSynthesis){ window.speechSynthesis.cancel(); } }catch{}
  // Flush any queued utterances so a new prompt starts fresh
  try{ speakQ = Promise.resolve(); }catch{}
  // Abort any active streaming request so it doesn't enqueue more sentences
  try{ if(curStreamCtrl){ curStreamCtrl.abort(); curStreamCtrl = null; } }catch{}
  // Abort any active TTS fetch
  try{ if(curTtsCtrl){ curTtsCtrl.abort(); curTtsCtrl = null; } }catch{}
}
const VMAP = { "sil":0.00, "p":0.15, "t":0.2, "f":0.22, "k":0.22, "S":0.2, "T":0.22, "r":0.28, "w":0.3,
               "e":0.55, "i":0.6, "o":0.75, "u":0.78, "@":0.5, "a":0.95 };
function visemeToOpen(v){ return (VMAP[v] ?? 0.35); }

async function playAudioWithVisemes(b64, marks){
  return new Promise(async (resolve, reject)=>{
    stopSpeaking(); speaking=true;
  // Keep mic active; just suppress ASR results while speaking
  suppressASRUntil = Number.POSITIVE_INFINITY;
    const audio = new Audio('data:audio/mp3;base64,'+b64); currentAudio=audio;

    let cleaned=false;
    const cleanup=(endOk=true)=>{
      if(cleaned) return; cleaned=true;
      try{ if(raf) cancelAnimationFrame(raf); }catch{}
      setJawEnergy(0);
      try{ audio.pause(); audio.src=''; }catch{}
      try{ if(audioCtx){ audioCtx.close(); } }catch{}
      audioCtx = null; currentAudio = null; speaking = false;
  // After TTS ends, ignore ASR results briefly (slightly longer to avoid overlap)
  suppressASRUntil = performance.now() + 1000;
      endOk ? resolve() : reject(new Error('audio-playback-failed'));
    };

    try{
      audioCtx = new (window.AudioContext||window.webkitAudioContext)();
      const src = audioCtx.createMediaElementSource(audio);
      const an  = audioCtx.createAnalyser(); an.fftSize=512;
      src.connect(an); an.connect(audioCtx.destination);

      try{ if(audioCtx.state!=='running') await audioCtx.resume(); }catch{}
      let started=false;
      audio.onplay = ()=>{ started=true; };
      audio.onerror = ()=> cleanup(false);
      const startWatch = setTimeout(()=>{ if(!started) cleanup(false); }, 2500);
  audio.onended = ()=>{ clearTimeout(startWatch); cleanup(true); };
  // If we interrupt (stopSpeaking pauses audio), treat as a clean end so the queue continues
  audio.onpause = ()=>{ clearTimeout(startWatch); cleanup(true); };
      audio.play().catch(()=> cleanup(false));

      let idx=0, target=0.2, level=0.15;
      const startAt = audioCtx.currentTime;
      const data = new Uint8Array(an.frequencyBinCount);

      const tick=()=>{
        if(!speaking || cleaned) return;
        const tms = (audioCtx.currentTime - startAt)*1000;

        while(Array.isArray(marks) && idx<marks.length && marks[idx].time <= tms + 30){
          target = visemeToOpen(marks[idx].value); idx++;
        }

        an.getByteTimeDomainData(data);
        let s=0; for(let i=0;i<data.length;i++){ const v=(data[i]-128)/128; s+=v*v; }
        const rms=Math.sqrt(s/data.length);
        const assist = Math.min(0.25, rms*0.6);

        level = level*0.6 + (target+assist)*0.4;
        setJawEnergy(Math.max(0, Math.min(1, level)));

        raf = requestAnimationFrame(tick);
      };
      raf = requestAnimationFrame(tick);
    }catch(e){ cleanup(false); }
  });
}

let speakQ = Promise.resolve();
let talkGen = 0; // generation id for active talk stream
function speakWithBrowser(sentence){
  return new Promise((resolve)=>{
  // Disabled to prevent male browser voice fallback; resolve immediately.
  return resolve();
  });
}

// Strip labels (e.g., "Title:", "Chorus -") and stage cues like [smiles] from captions/TTs
function sanitizeCaption(input){
  let s = String(input||'');
  // Remove square-bracket stage directions entirely
  s = s.replace(/\[[^\]]*\]/g, ' ');
  // Remove short parenthetical cues like (smiles), (laughs), (beat)
  s = s.replace(/\(([^)]{1,24})\)/g, (m, inner)=> (/^[a-zA-Z\s]+$/.test(inner) ? ' ' : m));
  // Remove leading labels like Title:, Summary:, Chorus -, Verse ‚Äî, etc.
  s = s.replace(/^\s*(?:title|subtitle|summary|note|action|directions?|stage|heading|scene|lyrics|chorus|verse|bridge|intro|outro)\s*:\s*/i, '');
  s = s.replace(/^\s*(?:title|subtitle|summary|note|action|directions?|stage|heading|scene|lyrics|chorus|verse|bridge|intro|outro)\s*[-‚Äì‚Äî]\s*/i, '');
  // Collapse whitespace and stray punctuation from removals
  s = s.replace(/\s{2,}/g, ' ').replace(/\s+([,.;:!?])/g, '$1').trim();
  return s;
}

function enqueueSpeak(sentence){
  const s = (sentence||'').trim(); if(!s) return;
  const cleaned = sanitizeCaption(s); if(!cleaned) return;
  speakQ = speakQ.then(async ()=>{
    try{
      const {audio_b64, marks} = await ttsFull(cleaned);
      if(!audio_b64){ throw new Error('no-audio'); }
      await playAudioWithVisemes(audio_b64, marks || []);
    }catch(e){
  if(e && (e.name==='AbortError' || String(e).includes('AbortError'))){ return; }
  console.warn('Server TTS failed; skipping speech to avoid browser voice', e);
  // Intentionally skip browser speech so voice never changes from Ruth
    }
  });
}

/* ====== Subtitles + panel toggle ====== */
let subTimer; function showSubtitle(text, ttl=4000){
  const t = sanitizeCaption(text);
  if(!t){ subtitle.classList.remove('show'); return; }
  subtitle.textContent = t; subtitle.classList.add('show');
  if(subTimer) clearTimeout(subTimer);
  subTimer = setTimeout(()=>subtitle.classList.remove('show'), ttl);
}
hambtn.onclick = ()=>{ panelEl.classList.toggle('open'); };
// Close panel on outside click
document.addEventListener('click', (ev)=>{
  if(!panelEl.classList.contains('open')) return;
  if(panelEl.contains(ev.target) || hambtn.contains(ev.target)) return;
  panelEl.classList.remove('open');
});
// Close panel on Escape
document.addEventListener('keydown', (ev)=>{
  if(ev.key === 'Escape'){ panelEl.classList.remove('open'); }
});

/* ====== Streaming chat (with sentence-level TTS) ====== */
async function talk(text){
  const myGen = ++talkGen;
  stopSpeaking();
  const q = (text||'').trim(); if(!q) return;
  try{ lastLangHint = detectLang(q) || lastLangHint; }catch{}
  add(q,'user');

  const bubble = document.createElement('div'); bubble.className='bubble bot'; bubble.textContent=''; logEl.appendChild(bubble);
  // Show a transient typing indicator while we wait for first tokens
  let showedTyping = false; let typingTimer = setTimeout(()=>{ if(!showedTyping){ logEl.appendChild(typingEl); typingEl.scrollIntoView({behavior:'smooth', block:'end'}); showedTyping=true; } }, 280);

  let buf=''; const dec=new TextDecoder();
  try{
    // Create a fresh controller for this stream and store it globally for interruption
    // Add a client-side timeout to avoid hanging streams
    const streamCtrl = new AbortController();
    curStreamCtrl = streamCtrl;
  const streamTimeout = setTimeout(()=>{ try{ streamCtrl.abort(); }catch{} }, 40000);
  const r = await fetch('/api/chat_stream', {method:'POST', headers:{'Content-Type':'application/json'}, body:JSON.stringify({text:q, session_id:'local-1', style: selectedStyle}), signal: streamCtrl.signal});
    if(!r.ok){ throw new Error('stream-status-'+r.status); }
    const reader = r.body.getReader(); let leftover='';
    while(true){
      const {value, done} = await reader.read();
      if(done){ break; }
      if(myGen !== talkGen){ break; }
      // Remove typing indicator upon first chunk
      if(showedTyping){ typingEl.remove(); showedTyping=false; clearTimeout(typingTimer); }
      leftover += dec.decode(value, {stream:true});
      const lines = leftover.split('\n'); leftover = lines.pop();
      for(const line of lines){
        if(!line.trim()) continue;
        const {delta='', error} = JSON.parse(line);
        if(error){
          bubble.textContent += ` [${error}]`;
          if(/Chat busy|Bedrock error|Stream failure/i.test(error)){
            throw new Error('fallback-chat');
          }
          continue;
        }
  bubble.textContent += delta; buf += delta; showSubtitle(bubble.textContent.slice(-220));

        const m = buf.match(/(.+?[.!?][)"']?\s)/);
        if(m && m[1].trim().length>3){ enqueueSpeak(m[1]); buf = buf.slice(m[1].length); }
      }
    }
  // Ensure typing indicator is cleared if still present
  try{ if(showedTyping){ typingEl.remove(); showedTyping=false; } }catch{}; clearTimeout(typingTimer);
  if(myGen !== talkGen){ clearTimeout(streamTimeout); curStreamCtrl = null; return; }
  clearTimeout(streamTimeout);
  if(buf.trim()) { showSubtitle(buf.trim()); try{ lastLangHint = detectLang(buf) || lastLangHint; }catch{}; enqueueSpeak(buf.trim()); buf=''; }
    await speakQ;
    curStreamCtrl = null;
  }catch(e){
  try{ if(showedTyping){ typingEl.remove(); } }catch{}; clearTimeout(typingTimer);
    console.error(e);
    if(e && (e.name==='AbortError' || String(e).includes('AbortError'))){
      // Interrupted: do not fallback or enqueue; just stop cleanly
      curStreamCtrl = null;
      return;
    }
    // Small backoff then fallback to non-streaming
    await new Promise(res=>setTimeout(res, 250));
  // Add a timeout for non-streaming as well
  const nonCtrl = new AbortController(); const nonTimeout = setTimeout(()=>{ try{ nonCtrl.abort(); }catch{} }, 12000);
  const rr = await fetch('/api/chat', {method:'POST', headers:{'Content-Type':'application/json'}, body:JSON.stringify({text:q, session_id:'local-1', style: selectedStyle}), signal: nonCtrl.signal});
    const dd = await rr.json(); bubble.textContent = dd.reply || "I'm here.";
  clearTimeout(nonTimeout);
    showSubtitle(bubble.textContent); enqueueSpeak(bubble.textContent); await speakQ;
    curStreamCtrl = null;
  }
}

/* ====== inputs & mic ====== */
sendBtn.onclick = ()=>{ const t = inp.value.trim(); if(t){ talk(t); inp.value=''; } };
inp.addEventListener('keydown', e=>{ if(e.key==='Enter'){ e.preventDefault(); sendBtn.click(); } });

const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
let recog, localCtx;
let listening = false; // track mic listening state
let ptt = { enabled: false, key: ' ' }; // push-to-talk (Space)
const ASR_LANGS = { en: 'en-US', es: 'es-ES', 'es-mx': 'es-MX', fr: 'fr-FR', 'fr-ca': 'fr-CA', hi: 'hi-IN' };
function resolveAsrLang(){
  if(selectedLang && selectedLang !== 'auto') return ASR_LANGS[selectedLang] || 'en-US';
  return ASR_LANGS[lastLangHint] || 'en-US';
}
function beep(freq=880, ms=120){
  try{
    localCtx = localCtx || new (window.AudioContext||window.webkitAudioContext)();
    const o=localCtx.createOscillator(), g=localCtx.createGain();
    o.type='sine'; o.frequency.value=freq; o.connect(g); g.connect(localCtx.destination);
    g.gain.setValueAtTime(0.0001, localCtx.currentTime);
    g.gain.exponentialRampToValueAtTime(0.25, localCtx.currentTime+0.02);
    g.gain.exponentialRampToValueAtTime(0.0001, localCtx.currentTime+ms/1000);
    o.start(); o.stop(localCtx.currentTime+ms/1000);
  }catch{}
}
function setListening(on){
  listening = !!on;
  micdot.classList.toggle('on', on);
  miclabel.textContent = on ? 'Listening‚Ä¶' : 'Idle';
  if(on && speaking) stopSpeaking();
}
function startMic(){
  if(!SpeechRecognition){ alert("Use Chrome/Edge for live speech. I can add Whisper fallback next."); return; }
  if(recog || listening){ return; }
  const r = new SpeechRecognition();
  recog = r; r.lang = resolveAsrLang(); r.interimResults=true; r.continuous=true;
  let buffer=''; let lastFinalAt=0; const DEBOUNCE_MS=250;
  r.onstart = ()=>{ micBtn.disabled=true; stopBtn.disabled=false; setListening(true); try{ beep(820,120); }catch{} };
  r.onresult = (ev)=>{
    // Ignore any recognition results for a brief window after TTS ends
  // Don't interrupt active TTS mid-utterance
  if(speaking || performance.now() < suppressASRUntil){ return; }
    let gotFinal = false;
    for(let i=ev.resultIndex;i<ev.results.length;i++){
      const rr=ev.results[i]; if(rr.isFinal){ buffer += ' '+rr[0].transcript; gotFinal=true; }
    }
    if(gotFinal){
      const now = performance.now();
      if(now - lastFinalAt < DEBOUNCE_MS){ return; }
      lastFinalAt = now;
      const cleaned = buffer.trim(); if(cleaned){ talk(cleaned); buffer=''; }
    }
  };
  r.onend = ()=>{ micBtn.disabled=false; stopBtn.disabled=true; setListening(false); try{ beep(480,120); }catch{}; recog = null; };
  r.onerror = e=> console.warn(e);
  try{ r.start(); }catch(e){ console.warn('recog.start failed', e); }
}
function stopMic(){ try{ if(recog){ recog.stop(); } }catch(e){}
}
micBtn.onclick = ()=> startMic();
stopBtn.onclick = ()=>{
  // User intent to stop everything: do not auto-resume mic after current TTS
  autoResumeMic = false;
  try{ if(recog) recog.stop(); }catch{}
  stopSpeaking();
};
// PTT toggle button
const pttBtn = document.getElementById('pttbtn');
function updatePttBtn(){
  if(!pttBtn) return;
  pttBtn.style.outline = ptt.enabled ? '2px solid var(--green)' : '';
  pttBtn.textContent = ptt.enabled ? 'PTT ‚Ä¢ On' : 'PTT';
}
pttBtn?.addEventListener('click', ()=>{ ptt.enabled = !ptt.enabled; updatePttBtn(); try{ localStorage.setItem('pref-ptt', ptt.enabled?'1':'0'); }catch{} });
// Restore PTT pref
try{ ptt.enabled = localStorage.getItem('pref-ptt')==='1'; }catch{}
updatePttBtn();
// PTT keyboard: hold Space to talk
window.addEventListener('keydown', (e)=>{
  if(!ptt.enabled) return;
  if(e.key === ' ' && !e.repeat){
    // Start mic when space is pressed
    if(!listening) startMic();
  }
}, {passive:true});
window.addEventListener('keyup', (e)=>{
  if(!ptt.enabled) return;
  if(e.key === ' '){
    // Stop mic when space is released
    if(listening) stopMic();
  }
}, {passive:true});
// Language selection
langSel.addEventListener('change', ()=>{
  selectedLang = langSel.value || 'auto';
  // If ASR is running, restart it to apply new language
  try{
    if(recog){ recog.stop(); setTimeout(()=>{ startMic(); }, 200); }
  }catch{}
});
// Removed PTT/test controls to simplify UI
// Sing: use the dedicated Sing input so it doesn't mix with chat prompt
async function doSingFromInput(){
  const lyrics = (singInp?.value||'').trim();
  if(!lyrics){ add('Type lyrics in the Sing box.','bot'); return; }
  stopSpeaking();
  try{
    const {audio_b64, marks} = await singOnce(lyrics);
    await playAudioWithVisemes(audio_b64, marks||[]);
  }catch(e){ console.warn(e); add('Singing failed. Please try again.','bot'); }
}
singBtn.onclick = async ()=>{
  panelEl.classList.add('open');
  singInp?.focus();
  if((singInp?.value||'').trim()){ doSingFromInput(); }
};
singGoBtn?.addEventListener('click', ()=>{ doSingFromInput(); });

// Suggestions chips
for (const b of suggestionButtons()){
  b.addEventListener('click', ()=>{
    const v = b.getAttribute('data-say')||''; if(v){ talk(v); }
  });
}
// Quick knowledge card button
document.getElementById('cardBtn')?.addEventListener('click', async ()=>{
  const topic = (inp.value.trim() || 'a surprising science fact');
  const prompt = `Create a concise knowledge card about ${topic}. Include: Title, 3 bullet points, a one-line takeaway.`;
  add(`Card: ${topic}`,'user');
  try{
    const r = await fetch('/api/chat', {method:'POST', headers:{'Content-Type':'application/json'}, body:JSON.stringify({text: prompt, session_id:'local-1', style: selectedStyle})});
    const d = await r.json();
    const card = document.createElement('div'); card.className='bubble bot'; card.innerHTML = (d.reply||'').replace(/\n/g,'<br>');
    logEl.appendChild(card); card.scrollIntoView({behavior:'smooth', block:'end'});
    showSubtitle('Here‚Äôs a quick card'); enqueueSpeak(d.reply||'Here is a quick card.');
  }catch(e){ console.warn(e); }
});
// Removed bottom bar card and spicy duplicates
// Style chips (Grok-like persona modes)
for (const b of styleButtons()){
  b.addEventListener('click', ()=>{
  const chosen = b.getAttribute('data-style') || null;
  // Toggle off if clicking the same style again
  selectedStyle = (selectedStyle === chosen) ? null : chosen;
    // Visual toggle
    styleButtons().forEach(x=> x.style.outline = '');
  if(selectedStyle){ b.style.outline = '2px solid var(--green)'; }
  showSubtitle(`Mode: ${selectedStyle||'default'}`, 1500);
  });
}

// Removed extra bar toggles and what's-new toast wiring

// Reactions removed for a cleaner UI

// Zoom controls
function dolly(f){
  try{
    if(controls && typeof controls.dollyIn === 'function'){
      if(f>1){ controls.dollyIn(f); } else { controls.dollyOut(1/f); }
      controls.update(); return;
    }
  }catch{}
  try{
    const to = new THREE.Vector3();
    to.copy(controls?.target || new THREE.Vector3(0,0,0));
    const v = new THREE.Vector3().subVectors(camera.position, to).multiplyScalar(1/f);
    camera.position.copy(v.add(to)); camera.updateProjectionMatrix(); controls?.update();
  }catch{}
}
zoomInBtn?.addEventListener('click', ()=> dolly(1.2));
zoomOutBtn?.addEventListener('click', ()=> dolly(1/1.2));
zoomReset?.addEventListener('click', ()=>{ try{ controls.reset(); }catch{}; try{ if(root) frameObject(root); }catch{} });

// Try to unlock/resume audio on any user gesture, to avoid autoplay gating after interruptions
['pointerdown','keydown'].forEach(evt=>{
  window.addEventListener(evt, ()=>{
    try{ if(audioCtx && audioCtx.state!=='running'){ audioCtx.resume(); } }catch{}
    try{ if(window.speechSynthesis && window.speechSynthesis.paused){ window.speechSynthesis.resume?.(); } }catch{}
    // iOS: create a silent buffer to unlock audio context on first tap
    try{
      if(!window.__unlocked && (window.AudioContext||window.webkitAudioContext)){
        const ctx = new (window.AudioContext||window.webkitAudioContext)();
        const node = ctx.createBufferSource(); node.buffer = ctx.createBuffer(1,1,22050); node.connect(ctx.destination); node.start(0);
        window.__unlocked = true;
      }
    }catch{}
  }, {passive:true});
});
</script>
</body>
</html>